// Generated by CoffeeScript 1.6.3
var COMMON_CHAR_RANGE, Events, Lexer, NAME_CHAR_RANGE, Range, SPACE_CHAR_RANGE, START_CHAR_RANGE,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Events = require('events');

Range = require('./range');

SPACE_CHAR_RANGE = {
  has: function(char) {
    return char === ' ';
  }
};

/*COMMON_CHAR_RANGE = Range.union(
	new Range('\x01', '\ud7ff')
	new Range('\ue000', '\ufffd')
	# [#x10000-#x10FFFF]
)
*/


COMMON_CHAR_RANGE = {
  has: function() {
    return true;
  }
};

/*START_CHAR_RANGE = Range.union(
	':', '_'

	new Range('A', 'Z')
	new Range('a', 'z')

	new Range('\xc0', '\xd6')
	new Range('\xd8', '\xf6')

	new Range('\u00f8', '\u02ff')
	# new Range('\0300', '\u036f')	Combining Diacritical Marks
	new Range('\u0370', '\u037d')
	# '\u037e'	Greek Question Mark
	new Range('\u037f', '\u1fff')
	new Range('\u200c', '\u200d')
	new Range('\u2070', '\u218f')
	new Range('\u2c00', '\u2fef')
	new Range('\u3001', '\ud7ff')
	new Range('\uf900', '\ufdcf')
	new Range('\ufdf0', '\ufffd')
	# [#x10000-#xEFFFF]
)
*/


START_CHAR_RANGE = {
  has: function(char) {
    return char !== ' ' && char !== '?';
  }
};

/*NAME_CHAR_RANGE = START_CHAR_RANGE.union(
	'-', '.', '\xb7'

	new Range('0', '9')
	new Range('\u0300', '\u036f')
	new Range('\u203f', '\u2040')
)
*/


NAME_CHAR_RANGE = {
  has: function(char) {
    return char !== ' ' && char !== '?';
  }
};

Lexer = (function(_super) {
  var STATES;

  __extends(Lexer, _super);

  STATES = {
    START: 10,
    OPEN_BRACKET: 11,
    EXCLAMATION: 12,
    NONE: void 0,
    ERROR: -1,
    CDATA_CONTENT: 20,
    CDATA_MAYBE_ERROR: 21,
    CDATA_NEAR_ERROR: 22,
    OPEN_TAG_NAME: 50,
    OPEN_TAG_SPACE: 51,
    OPEN_TAG_SLASH: 52,
    CLOSE_TAG_NAME: 53,
    CLOSE_TAG_SPACE: 54,
    ATTR_NAME: 60,
    ATTR_PRE_EQ: 61,
    ATTR_POST_EQ: 62,
    ATTR_DQ_VALUE: 63,
    ATTR_SQ_VALUE: 64,
    ATTR_END: 65,
    COMMENT_START: 70,
    COMMENT_CONTENT: 71,
    COMMENT_MAYBE_END: 72,
    COMMENT_END: 73,
    PI_TARGET: 80,
    PI_TARGET_REST: 81,
    PI_CONTENT: 82,
    PI_END1: 83,
    PI_END2: 84
  };

  function Lexer() {
    this._state = STATES.START;
    this._line = null;
    this._column = null;
    this._data = {};
  }

  Lexer.prototype._onStartAlt = function() {
    var position;
    position = this._position;
    if (this._text.slice(position, position + 4) === '<!--') {
      this._state = STATES.COMMENT_BODY;
      this._position += 4;
    } else if (this._text.slice(position, position + 9) === '<![CDATA[') {
      this._state = STATES.CDATA_BODY;
      this._position += 9;
    } else if (this._text.slice(position, position + 2) === '<?') {
      this._state = STATES.PI_TARGET;
      this._position += 2;
    } else if (this._text[position] === '&') {
      this._state = STATES.REFERENCE;
    } else if (START_CHAR_RANGE.has(this._text[position])) {
      this._state = STATES.TEXT;
    } else {
      this._state = STATES.ERROR;
    }
    this._position++;
    return this;
  };

  Lexer.prototype._start = function() {
    var char;
    char = this._text[this._position];
    if (char === '<') {
      this._position++;
      this._state = STATES.OPEN_BRACKET;
    } else if (char === '&') {
      this._position++;
      this._state = STATES.REFERENCE;
    } else if (START_CHAR_RANGE.has(char)) {
      this._position++;
      this._state = STATES.TEXT;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._openBracket = function() {
    var char;
    char = this._text[this._position];
    if (char === '!') {
      this._position++;
      this._state = STATES.EXCLAMATION;
    } else if (char === '?') {
      this._position++;
      this._state = STATES.PI_TARGET;
    } else if (START_CHAR_RANGE.has(char)) {
      this._position++;
      this._state = STATES.TAG_NAME;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onExclamation = function(char) {
    switch (char) {
      case '-':
        this._state = STATES.COMMENT_START;
        break;
      case '[':
        this._state = STATES.CDATA_START;
        break;
      default:
        this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onOpenTagName = function(char) {
    if (NAME_CHAR_RANGE.has(char)) {
      return this;
    }
    if (char === '/') {
      this._state = STATES.OPEN_TAG_SLASH;
    } else if (char === '>') {
      this._state = STATES.START;
    } else if (SPACE_CHAR_RANGE.has(char)) {
      this._state = STATES.OPEN_TAG_SPACE;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onOpenTagSpace = function(char) {
    if (SPACE_CHAR_RANGE.has(char)) {
      return this;
    }
    if (char === '/') {
      this._state = STATES.OPEN_TAG_SLASH;
    } else if (char === '>') {
      this._state = STATES.START;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onOpenTagSlash = function(char) {
    if (char === '>') {
      this._state = STATES.START;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onCloseTagName = function(char) {
    if (NAME_CHAR_RANGE.has(char)) {
      return this;
    }
    if (char === '>') {
      this._state = STATES.START;
    } else if (SPACE_CHAR_RANGE.has(char)) {
      this._state = STATES.CLOSE_TAG_SPACE;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onCloseTagSpace = function(char) {
    if (SPACE_CHAR_RANGE.has(char)) {
      return this;
    }
    if (char === '>') {
      this._state = STATES.START;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._commentStart = function(char) {
    if (char('-')) {
      this._state = STATES.COMMENT_CONTENT;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._commentContent = function(char) {
    if (COMMON_CHAR_RANGE.has(char)) {
      return this;
    }
    if (char === '-') {
      this._state = STATES.COMMENT_MAYBE_END;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._commentMaybeEnd = function(char) {
    if (COMMON_CHAR_RANGE.has(char)) {
      this._state = STATES.COMMENT_CONTENT;
    } else if (char === '-') {
      this._state = STATES.COMMENT_END;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._commentEnd = function(char) {
    if (char === '>') {
      this._state = STATES.START;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._piTarget = function() {
    var char;
    char = this._text[this._position];
    if (START_CHAR_RANGE.has(char)) {
      this._data.start = this._position;
      this._position++;
      this._state = STATES.PI_TARGET_REST;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._piTargetRest = function() {
    var char;
    char = this._text[this._position];
    if (char === '?') {
      this._data.target = this._text.slice(this._data.start, this._position);
      this._position++;
      this._state = STATES.PI_END2;
    } else if (SPACE_CHAR_RANGE.has(char)) {
      this._data.target = this._text.slice(this._data.start, this._position);
      this._data.start = this._position;
      this._position++;
      this._state = STATES.PI_CONTENT;
    } else if (NAME_CHAR_RANGE.has(char)) {
      this._position++;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._piContent = function() {
    var char;
    char = this._text[this._position];
    if (char === '?') {
      this._position++;
      this._state = STATES.PI_END1;
    } else if (COMMON_CHAR_RANGE.has(char)) {
      this._position++;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._piEnd1 = function() {
    var char, content, target;
    char = this._text[this._position];
    if (char === '>') {
      target = this._data.target;
      this._data.target = null;
      content = this._text.slice(this._data.start, this._position - 1);
      this._data.start = null;
      this._onPI(target, content);
      this._position++;
      this._state = STATES.START;
    } else if (COMMON_CHAR_RANGE.has(char)) {
      this._position++;
      this._state = STATES.PI_CONTENT;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._piEnd2 = function() {
    var char, target;
    char = this._text[this._position];
    if (char === '>') {
      target = this._data.target;
      this._data.target = null;
      this._onPI(target, null);
      this._position++;
      this._state = STATES.START;
    } else {
      this._state = STATES.ERROR;
    }
    return this;
  };

  Lexer.prototype._onComment = function(content) {
    console.log(content);
    return void 0;
  };

  Lexer.prototype._onPI = function(target, content) {
    console.log(target, content);
    return void 0;
  };

  Lexer.prototype.process = function(text) {
    var SIMPLE_HANDLERS;
    this._text = text;
    this._position = 0;
    this._state = STATES.START;
    SIMPLE_HANDLERS = {
      '10': '_start',
      '11': '_openBracket',
      '80': '_piTarget',
      '81': '_piTargetRest',
      '82': '_piContent',
      '83': '_piEnd1',
      '84': '_piEnd2'
    };
    while (this._position < this._text.length) {
      console.log(this._state, this._text[this._position]);
      this[SIMPLE_HANDLERS[this._state]]();
    }
    return this;
  };

  return Lexer;

})(Events.EventEmitter);

module.exports = Lexer;
