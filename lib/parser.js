// Generated by CoffeeScript 1.6.3
var Parser, SAX,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

SAX = require('sax');

Parser = (function() {
  function Parser(options) {
    this._onCDATA = __bind(this._onCDATA, this);
    this._onText = __bind(this._onText, this);
    this._onCloseTag = __bind(this._onCloseTag, this);
    this._onOpenTag = __bind(this._onOpenTag, this);
    this._empty = options.empty;
    this._tree = null;
    this._stack = null;
    this._current = null;
    this._sax = SAX.parser(true);
    this._sax.onopentag = this._onOpenTag;
    this._sax.onclosetag = this._onCloseTag;
    this._sax.ontext = this._onText;
    this._sax.oncdata = this._onCDATA;
  }

  Parser.prototype._onOpenTag = function(options) {
    var current;
    if (Object.keys(options.attributes).length) {
      current = {
        $: options.attributes
      };
    } else {
      current = null;
    }
    if (this._current === null) {
      this._current = {};
    } else if (typeof this._current === 'string') {
      this._current = {
        $text: this._current
      };
    }
    this._stack.push([options.name, this._current]);
    this._current = current;
    return void 0;
  };

  Parser.prototype._onCloseTag = function(name) {
    var prev, tag, _ref;
    _ref = this._stack.pop(), tag = _ref[0], prev = _ref[1];
    if (prev[tag] == null) {
      prev[tag] = this._current;
    } else if (!Array.isArray(prev[tag])) {
      prev[tag] = [prev[tag], this._current];
    } else {
      prev[tag].push(this._current);
    }
    this._current = prev;
    return void 0;
  };

  Parser.prototype._onText = function(value) {
    var char, isGarbage, _i, _len;
    isGarbage = true;
    for (_i = 0, _len = value.length; _i < _len; _i++) {
      char = value[_i];
      if (char !== '\n' && char !== '\t' && char !== ' ') {
        isGarbage = false;
        break;
      }
    }
    if (isGarbage) {
      return;
    }
    if (this._current === null) {
      this._current = value;
    } else if (typeof this._current === 'string') {
      this._current += value;
    } else {
      if (this._current.$text == null) {
        this._current.$text = value;
      } else if (!Array.isArray(this._current.$text)) {
        this._current.$text = [this._current.$text, value];
      } else {
        this._current.$text.push(value);
      }
    }
    return void 0;
  };

  Parser.prototype._onCDATA = function(value) {
    if (this._current === null) {
      this._current = {};
    } else if (typeof this._current === 'string') {
      this._current = {
        $text: this._current
      };
    }
    this._current.$section = value;
    return void 0;
  };

  Parser.prototype.process = function(text) {
    this._tree = {};
    this._stack = [];
    this._current = this._tree;
    this._sax.write(text).close();
    return this._tree;
  };

  return Parser;

})();

module.exports = Parser;
